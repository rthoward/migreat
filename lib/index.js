const path = require('path');
const fs = require('fs');
const _ = require('lodash/fp');

async function runMigrations(db, migrations, currentVersion, targetVersion) {
    if (migrations.length > 0) {
        console.log(` `)
    } else {
        console.log("Nothing to do.")
    }

    try {
        await db.runSql('BEGIN');

        for (let migration of migrations) {
            process.stdout.write(`Running [${migration.timestamp}] ${migration.label}...`);
            await migration.fn(db);
            process.stdout.write(` success.\n`)
        }

        await db.runSql(`UPDATE migrations SET timestamp = $1`, [targetVersion]);
        await db.runSql('COMMIT');
    } catch (error) {
        console.log(error)
        await db.runSql('ROLLBACK');
    }
}

async function currentVersion(settings) {
    const db = settings.db;
    const o = await db.runSql(`
    SELECT * FROM pg_catalog.pg_tables
    WHERE tablename = 'migrations'`);
    const tableExists = o.rows.length > 0;

    if (tableExists) {
        const o = await db.runSql(`SELECT timestamp FROM migrations`);
        return o.rows.length > 0 ?
            _.toInteger(o.rows[0].timestamp) : 0;
    } else {
        await db.runSql(`
            CREATE TABLE migrations (timestamp TEXT NOT NULL);
            INSERT INTO migrations VALUES (0);`);
        return null;
    }
};

function readMigrationFile(filePath) {
    const fields = _.split('__', path.basename(filePath));
    const content = require(filePath);
    let parsed = {};

    if (fields.length > 1) {
        parsed = {
            label: fields[1].split('.')[0],
            timestamp: _.toInteger(_.split('.', fields[0])[0]),
            up: content.up,
            down: content.down
        };
    } else {
        parsed = {
            timestamp: _.toInteger(_.split('.', fields[0])[0]),
            up: content.up,
            down: content.down
        };
    };
    return parsed;
};

module.exports = {

    gen: function(settings) {
        const label = process.argv[3];
        const migrationTimeStamp = new Date().getTime();
        const labelSuffix = label ? `__${label}` : '';
        const migrationFileName = `${migrationTimeStamp}${labelSuffix}.js`
        const migrationFilePath = path.join(settings.migrationDir, migrationFileName);
    const MIGRATION_TEMPLATE = `module.exports = {
// ${migrationFileName}
// Generated by migreat

    up: (db) => {

    },

    down: (db) => {

    }
};
`;
        fs.writeFileSync(migrationFilePath, MIGRATION_TEMPLATE);
        console.log(`Created migration ${migrationFileName}.`);
    },

    up: async function(settings, targetVersion) {
        const _currentVersion = await currentVersion(settings);
        targetVersion = targetVersion || new Date().getTime();

        const pendingMigrations = _.flow(
            fs.readdirSync,
            _.map((fname) => (path.join(settings.migrationDir, fname))),
            _.map(readMigrationFile),
            _.filter(o => (o.timestamp > _currentVersion &&
                           o.timestamp <= targetVersion)),
            _.map(o => ({...o, fn: o.up})),
            _.sortBy(o => (o.timestamp)))(settings.migrationDir);

        const _targetVersion = pendingMigrations.length > 0 ?
            _.last(pendingMigrations).timestamp : targetVersion;

        await runMigrations(
            settings.db, pendingMigrations, _currentVersion, _targetVersion);
    },

    down: async function(settings, targetVersion) {
        const _currentVersion = await currentVersion(settings);
        targetVersion = targetVersion || 0;

        const pendingMigrations = _.flow(
            fs.readdirSync,
            _.map((fname) => (path.join(settings.migrationDir, fname))),
            _.map(readMigrationFile),
            _.filter(o => (o.timestamp > targetVersion &&
                           o.timestamp <= _currentVersion)),
            _.map(o => ({...o, fn: o.down})),
            _.sortBy(o => (o.timestamp)),
            _.reverse)(settings.migrationDir);

        await runMigrations(
            settings.db, pendingMigrations, _currentVersion, targetVersion);
    },

}
